use crate::model::{HostInfoEmulation, VbanRecv, VbanSend};

pub fn filename_send(id_simple: &str) -> String {
    format!("99-rustban-send-{id_simple}.conf")
}

pub fn filename_recv(id_simple: &str) -> String {
    format!("99-rustban-recv-{id_simple}.conf")
}

pub fn render_send(s: &VbanSend, emulation: &HostInfoEmulation) -> String {
    let target_object = s.target_object.trim();
    let target_object_line = if target_object.is_empty() {
        String::new()
    } else {
        format!(
            "        target.object = \"{}\"\n",
            escape_str(target_object)
        )
    };
    let host_info_lines = render_host_info_lines(emulation, &s.sess_name);

    format!(
        r#"# Generated by RustBAN
context.modules = [
  {{ name = libpipewire-module-vban-send
    args = {{
      destination.ip = "{dest_ip}"
      destination.port = {dest_port}
      sess.name = "{sess_name}"
      sess.media = "{sess_media}"

      audio.format = "{fmt}"
      audio.rate = {rate}
      audio.channels = {ch}

      stream.props = {{
        node.name = "{node_name}"
        node.description = "{node_desc}"
        node.always-process = {always_process}
        media.class = "Audio/Sink"
        media.name = "{media_name}"
{host_info_lines}{target_object_line}      }}
    }}
  }}
]
"#,
        dest_ip = s.destination_ip,
        dest_port = s.destination_port,
        sess_name = escape_str(&s.sess_name),
        sess_media = escape_str(&s.sess_media),
        fmt = escape_str(&s.audio_format),
        rate = s.audio_rate,
        ch = s.audio_channels,
        node_name = escape_str(&s.node_name),
        node_desc = escape_str(&s.node_description),
        always_process = if s.always_process { "true" } else { "false" },
        media_name = escape_str(&s.sess_name),
        host_info_lines = host_info_lines,
        target_object_line = target_object_line,
    )
}

pub fn render_recv(r: &VbanRecv, emulation: &HostInfoEmulation) -> String {
    let stream_name = r.stream_name.trim();
    let sess_match = if stream_name.is_empty() {
        "~.*"
    } else {
        stream_name
    };
    let media_name = if stream_name.is_empty() {
        "VBAN Recv"
    } else {
        stream_name
    };
    let host_info_lines = render_host_info_lines(emulation, media_name);

    format!(
        r#"# Generated by RustBAN
context.modules = [
  {{ name = libpipewire-module-vban-recv
    args = {{
      source.ip = "{src_ip}"
      source.port = {src_port}
      node.always-process = {always_process}
      sess.latency.msec = {latency}

      stream.rules = [
        {{
          matches = [
            {{ sess.name = "{sess_match}" }}
          ]
          actions = {{
            create-stream = {{
              stream.props = {{
                node.name = "{node_name}"
                node.description = "{node_desc}"
                media.class = "Audio/Source"
                media.name = "{media_name}"
{host_info_lines}
              }}
            }}
          }}
        }}
      ]
    }}
  }}
]
"#,
        src_ip = r.source_ip,
        src_port = r.source_port,
        always_process = if r.always_process { "true" } else { "false" },
        latency = r.latency_msec,
        sess_match = escape_str(sess_match),
        node_name = escape_str(&r.node_name),
        node_desc = escape_str(&r.node_description),
        media_name = escape_str(media_name),
        host_info_lines = host_info_lines,
    )
}

fn render_host_info_lines(emulation: &HostInfoEmulation, stream_label: &str) -> String {
    if !emulation.enabled {
        return String::new();
    }

    let mut out = String::new();
    push_prop_line(&mut out, "application.name", &emulation.app_name);
    push_prop_line(&mut out, "application.process.binary", &emulation.app_name);
    push_prop_line(&mut out, "application.process.host", &emulation.host_name);
    push_prop_line(&mut out, "application.process.user", &emulation.user_name);
    push_prop_line(&mut out, "client.name", &emulation.client_name);

    let stream_label = stream_label.trim();
    let host_name = emulation.host_name.trim();
    let node_nick = if !host_name.is_empty() && !stream_label.is_empty() {
        format!("{host_name} - {stream_label}")
    } else if !stream_label.is_empty() {
        stream_label.to_string()
    } else {
        host_name.to_string()
    };
    push_prop_line(&mut out, "node.nick", &node_nick);

    out
}

fn push_prop_line(out: &mut String, key: &str, value: &str) {
    let value = value.trim();
    if value.is_empty() {
        return;
    }
    out.push_str(&format!("        {key} = \"{}\"\n", escape_str(value)));
}

fn escape_str(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}
